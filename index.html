<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Audio Transcription Service - CS6620 Group 9</title>

  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height:100vh; padding:20px;
    }
    .container { max-width:900px; margin:0 auto; }
    .header { text-align:center; color:white; margin-bottom:30px; }
    .header h1 {
      font-size:2.5em; margin-bottom:10px;
      text-shadow:2px 2px 4px rgba(0,0,0,0.2);
    }
    .header p { font-size:1.1em; opacity:.95; }

    .main-card {
      background:white; border-radius:20px;
      box-shadow:0 20px 40px rgba(0,0,0,.1);
      overflow:hidden;
    }

    .tabs { display:flex; background:#f8f9fa; border-bottom:2px solid #e9ecef; }
    .tab {
      flex:1; padding:20px; text-align:center; cursor:pointer; background:none; border:none;
      font-size:1.1em; font-weight:600; color:#6c757d;
      transition:all .3s ease; position:relative;
    }
    .tab:hover { background:#fff; color:#667eea; }
    .tab.active { background:white; color:#667eea; }
    .tab.active::after {
      content:''; position:absolute; bottom:-2px; left:0; right:0; height:2px; background:#667eea;
    }

    .tab-content { padding:40px; min-height:400px; }
    .tab-panel { display:none; animation: fadeIn .5s ease; }
    .tab-panel.active { display:block; }

    @keyframes fadeIn { from{opacity:0;} to{opacity:1;} }

    /* Upload Section */
    .upload-area {
      border:3px dashed #dee2e6; border-radius:15px;
      padding:60px 30px; text-align:center; cursor:pointer; background:#fafbfc;
      transition:all .3s ease;
    }
    .upload-area:hover { border-color:#667eea; background:#f8f6ff; }
    .upload-area.dragover {
      border-color:#667eea; background:#f0edff; transform:scale(1.02);
    }
    .file-input { display:none; }
    .file-info {
      margin:20px 0; padding:15px; background:#f8f9fa; border-radius:10px; display:none;
    }
    .file-info.show { display:block; }

    .btn {
      padding:12px 30px; border:none; border-radius:8px;
      font-size:1.1em; font-weight:600; cursor:pointer;
      transition:all .3s ease; margin:10px 5px;
    }
    .btn-primary {
      background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);
      color:white;
    }
    .btn-primary:hover {
      transform:translateY(-2px);
      box-shadow:0 10px 20px rgba(102,126,234,.3);
    }
    .btn-primary:disabled { opacity:.5; cursor:not-allowed; transform:none; }
    .btn-secondary { background:#e9ecef; color:#495057; }
    .btn-secondary:hover { background:#dee2e6; }
    .btn-small { padding:8px 16px; font-size:.9em; }
    .download-btn { background:#28a745; color:white; }
    .download-btn:hover { background:#218838; transform:translateY(-2px); }

    /* Status Messages */
    .status-message {
      margin:20px 0; padding:15px 20px; border-radius:10px; display:none;
      animation: slideInDown .5s ease;
    }
    .status-message.show { display:block; }
    .status-message.success {
      background:#d4edda; color:#155724; border-left:4px solid #28a745;
    }
    .status-message.error {
      background:#f8d7da; color:#721c24; border-left:4px solid #dc3545;
    }
    .status-message.info {
      background:#d1ecf1; color:#0c5460; border-left:4px solid #17a2b8;
    }

    @keyframes slideInDown {
      from { transform:translateY(-10px); opacity:0; }
      to { transform:translateY(0); opacity:1; }
    }

    /* Jobs */
    .jobs-container { max-height:500px; overflow-y:auto; }
    .job-card {
      background:#f8f9fa; border-radius:10px; padding:20px; margin-bottom:15px;
      transition:all .3s ease; border:2px solid transparent;
    }
    .job-card:hover {
      border-color:#667eea; transform:translateX(5px);
      box-shadow:0 5px 15px rgba(0,0,0,.1);
    }
    .job-header {
      display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;
    }
    .job-id { font-family:'Courier New', monospace; color:#6c757d; font-size:.9em; }
    .job-status {
      padding:5px 12px; border-radius:20px; font-size:.85em; font-weight:600; text-transform:uppercase;
    }
    .status-completed { background:#d4edda; color:#155724; }
    .status-transcribing { background:#fff3cd; color:#856404; }
    .status-waiting_upload { background:#d1ecf1; color:#0c5460; }
    .status-failed { background:#f8d7da; color:#721c24; }

    .job-actions { margin-top:15px; display:flex; gap:10px; flex-wrap:wrap; }

    /* Spinner */
    .spinner {
      border:3px solid #f3f3f3; border-top:3px solid #667eea; border-radius:50%;
      width:40px; height:40px; animation:spin 1s linear infinite; margin:10px auto;
    }
    @keyframes spin { 0%{transform:rotate(0);} 100%{transform:rotate(360deg);} }

    /* Preview panels + karaoke words */
    .karaoke-word {
      padding: 1px 2px;
      border-radius: 3px;
      cursor: pointer;
      transition: background 0.15s ease;
    }
    .karaoke-word.active {
      background: #facc15;  /* yellow */
      color: #111827;       /* dark text */
    }
    .preview-panel {
      background:#fff; border-radius:10px; padding:12px;
      border:1px solid #e9ecef; margin-top:12px;
    }
    .segment-line {
      padding:6px 0; border-bottom:1px dashed #eee; cursor:pointer;
    }
    .segment-line.active {
      background:#f8f6ff; border-left:4px solid #667eea; padding-left:8px; font-weight:600;
    }
    .live-box {
      background:#0f172a; color:#f8fafc; padding:12px; border-radius:8px; margin-top:10px;
      font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      white-space:pre-wrap; min-height:80px;
    }

    /* Empty State */
    .empty-state { text-align:center; padding:60px 20px; color:#6c757d; }
    .empty-state-icon { font-size:4em; color:#dee2e6; margin-bottom:20px; }

    @media (max-width:768px){
      .header h1{font-size:2em;}
      .tabs{flex-direction:column;}
      .tab-content{padding:20px;}
      .upload-area{padding:40px 20px;}
    }
  </style>
</head>

<body>
<div class="container">
  <div class="header">
    <h1>üéôÔ∏è Audio Transcription Service</h1>
    <p>CS6620 Group 9 - Cloud Computing Project</p>
  </div>

  <div class="main-card">
    <div class="tabs">
      <button class="tab active" onclick="switchTab('upload')">üì§ Upload Audio</button>
      <button class="tab" onclick="switchTab('jobs')">üìã My Transcriptions</button>
      <button class="tab" onclick="switchTab('about')">‚ÑπÔ∏è About</button>
    </div>

    <div class="tab-content">
      <!-- Upload Tab -->
      <div id="upload-tab" class="tab-panel active">
        <div class="upload-area" id="uploadArea"
             onclick="document.getElementById('audioFile').click()">
          <div style="font-size:4em;color:#667eea;margin-bottom:20px;">‚òÅÔ∏è</div>
          <h2>Drop your audio file here</h2>
          <p>or click to browse</p>
          <p style="margin-top:10px;color:#6c757d;font-size:.9em;">
            Supported: MP3, WAV, M4A (Max 25MB)
          </p>
        </div>

        <input type="file" id="audioFile" class="file-input"
               accept=".mp3,.wav,.m4a,audio/*"/>

        <div id="fileInfo" class="file-info">
          <strong>Selected File:</strong> <span id="fileName"></span><br>
          <strong>Size:</strong> <span id="fileSize"></span>
        </div>

        <div id="uploadStatus" class="status-message"></div>

        <!-- Waveform section -->
        <div id="waveform-section" style="display:none; margin-top:20px;">
          <h3 style="margin-bottom:10px;">Audio Preview</h3>
          <div id="waveform"
               style="width:100%; height:80px; background:#0f172a; border-radius:8px;"></div>
          <div style="margin-top:10px; display:flex; gap:10px; align-items:center;">
            <button id="waveformPlayBtn" class="btn btn-secondary btn-small"
                    onclick="toggleWaveformPlay()">
              ‚ñ∂Ô∏è Play
            </button>
            <span id="waveformInfo"
                  style="font-size:0.9em; color:#6c757d;">Ready to preview.</span>
          </div>
        </div>

        <div style="text-align:center;margin-top:20px;">
          <button id="uploadBtn" class="btn btn-primary"
                  onclick="uploadAudio()" style="display:none;">
            üöÄ Start Transcription
          </button>
          <button id="cancelBtn" class="btn btn-secondary"
                  onclick="cancelUpload()" style="display:none;">
            Cancel
          </button>
        </div>
      </div>

      <!-- Jobs Tab -->
      <div id="jobs-tab" class="tab-panel">
        <div style="margin-bottom:20px;display:flex;justify-content:space-between;align-items:center;">
          <h2>Your Transcription Jobs</h2>
          <button class="btn btn-secondary btn-small" onclick="refreshJobs()">üîÑ Refresh</button>
        </div>
        <div id="jobsList" class="jobs-container">
          <div class="empty-state">
            <div class="empty-state-icon">üì≠</div>
            <h3>No transcriptions yet</h3>
            <p>Upload an audio file to get started!</p>
          </div>
        </div>
      </div>

      <!-- About Tab -->
      <div id="about-tab" class="tab-panel">
        <h2>About This Project</h2><br>
        <p><strong>Project:</strong> Cloud-Based Audio-to-Text Transcription Service</p>
        <p><strong>Course:</strong> CS6620 - Cloud Computing</p>
        <p><strong>Group:</strong> Group 9</p><br>
        <h3>Features:</h3>
        <ul style="margin:20px 0;padding-left:20px;">
          <li>Upload audio files (MP3, WAV, M4A)</li>
          <li>Automatic speech-to-text transcription using AWS Transcribe</li>
          <li>Generate subtitle files (SRT, VTT formats)</li>
          <li>Download transcripts and subtitle files</li>
          <li>Live preview panel (polling)</li>
        </ul>
        <br>
        <h3>Architecture:</h3>
        <ul style="margin:20px 0;padding-left:20px;">
          <li><strong>Frontend:</strong> Static HTML/JS hosted on S3/Amplify</li>
          <li><strong>API:</strong> AWS API Gateway</li>
          <li><strong>Backend:</strong> AWS Lambda (Serverless)</li>
          <li><strong>Storage:</strong> AWS S3</li>
          <li><strong>Database:</strong> AWS DynamoDB</li>
          <li><strong>Transcription:</strong> AWS Transcribe</li>
        </ul>
      </div>
    </div>
  </div>
</div>

<!-- WaveSurfer library -->
<script src="https://unpkg.com/wavesurfer.js@7/dist/wavesurfer.min.js"></script>

<script>
  // ===== CONFIG =====
  const API_URL = 'https://ybe0mx1a1e.execute-api.us-east-1.amazonaws.com/Prod';
  const RESULTS_BUCKET = 'audio-transcribe-results-cs6620group9-1105';

  // ===== STATE =====
  let selectedFile = null;
  let refreshInterval = null;
  const livePollers = {}; // jobId -> intervalId

  // waveform state
  let waveSurfer = null;
  let currentAudioUrl = null;

  // remember open preview jobIds so refresh won't close them
  let openPreviews = new Set();

  // karaoke state
  const wordTimingsByJob = {};       // jobId -> [{start, end, word}]
  const currentWordIndexByJob = {};  // jobId -> index

  // ===== Tabs =====
  function switchTab(tabName) {
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    event.target.classList.add('active');

    document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
    document.getElementById(`${tabName}-tab`).classList.add('active');

    if (tabName === 'jobs') {
      loadJobs();
      if (refreshInterval) clearInterval(refreshInterval);
      refreshInterval = setInterval(loadJobs, 5000);
    } else {
      if (refreshInterval) {
        clearInterval(refreshInterval);
        refreshInterval = null;
      }
    }
  }

  // ===== Upload Handling =====
  const fileInput = document.getElementById('audioFile');
  const fileInfo = document.getElementById('fileInfo');
  const uploadBtn = document.getElementById('uploadBtn');
  const cancelBtn = document.getElementById('cancelBtn');
  const uploadArea = document.getElementById('uploadArea');

  uploadArea.addEventListener('dragover', (e) => {
    e.preventDefault();
    uploadArea.classList.add('dragover');
  });
  uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('dragover'));
  uploadArea.addEventListener('drop', (e) => {
    e.preventDefault();
    uploadArea.classList.remove('dragover');
    if (e.dataTransfer.files.length > 0) handleFileSelect(e.dataTransfer.files[0]);
  });

  fileInput.addEventListener('change', e => {
    if (e.target.files.length > 0) handleFileSelect(e.target.files[0]);
  });

  function handleFileSelect(file) {
    const ext = file.name.split('.').pop().toLowerCase();
    const validExtensions = ['mp3', 'wav', 'm4a'];
    if (!validExtensions.includes(ext)) {
      showStatus('Please select a valid audio file (MP3, WAV, or M4A)', 'error');
      return;
    }
    if (file.size > 25 * 1024 * 1024) {
      showStatus('File too large! Maximum size is 25MB', 'error');
      return;
    }

    selectedFile = file;
    document.getElementById('fileName').textContent = file.name;
    document.getElementById('fileSize').textContent = formatFileSize(file.size);
    fileInfo.classList.add('show');

    uploadBtn.style.display = 'inline-block';
    cancelBtn.style.display = 'inline-block';

    showStatus('File ready to upload', 'info');

    // waveform handling
    const wfSection = document.getElementById('waveform-section');
    wfSection.style.display = 'block';

    if (currentAudioUrl) {
      URL.revokeObjectURL(currentAudioUrl);
    }
    currentAudioUrl = URL.createObjectURL(file);

    if (!waveSurfer) {
      waveSurfer = WaveSurfer.create({
        container: '#waveform',
        height: 80,
        waveColor: '#38bdf8',
        progressColor: '#a855f7',
        cursorColor: '#facc15',
        normalize: true,
      });

      waveSurfer.on('finish', () => {
        const btn = document.getElementById('waveformPlayBtn');
        btn.textContent = '‚ñ∂Ô∏è Play';
        document.getElementById('waveformInfo').textContent = 'Playback finished.';
      });
    }

    waveSurfer.load(currentAudioUrl);
    document.getElementById('waveformInfo').textContent = 'Waveform loaded. Press Play.';
    document.getElementById('waveformPlayBtn').textContent = '‚ñ∂Ô∏è Play';
  }

  function cancelUpload() {
    selectedFile = null;
    fileInput.value = '';
    fileInfo.classList.remove('show');
    uploadBtn.style.display = 'none';
    cancelBtn.style.display = 'none';
    hideStatus();

    const wfSection = document.getElementById('waveform-section');
    wfSection.style.display = 'none';

    if (waveSurfer) {
      waveSurfer.stop();
      waveSurfer.empty();
    }
    if (currentAudioUrl) {
      URL.revokeObjectURL(currentAudioUrl);
      currentAudioUrl = null;
    }
  }

  async function uploadAudio() {
    if (!selectedFile) {
      showStatus('Please select a file first', 'error');
      return;
    }

    try {
      uploadBtn.disabled = true;
      cancelBtn.disabled = true;

      showStatus('Getting upload URL...', 'info');
      const response = await fetch(`${API_URL}/upload-url`);
      if (!response.ok) throw new Error(`Server error: ${response.status}`);

      const rawData = await response.json();
      const data = rawData.body ? JSON.parse(rawData.body) : rawData;

      showStatus('Uploading file to cloud...', 'info');
      const uploadResponse = await fetch(data.uploadUrl, {
        method: 'PUT',
        body: selectedFile,
        headers: { 'Content-Type': selectedFile.type || 'audio/mpeg' }
      });
      if (!uploadResponse.ok) throw new Error(`Upload failed: ${uploadResponse.status}`);

      saveJobToSessionStorage(data.jobId, selectedFile.name);
      showStatus(`‚úÖ Upload successful! Job ID: ${data.jobId}`, 'success');

      setTimeout(() => {
        cancelUpload();
        document.querySelectorAll('.tab')[1].click();
      }, 1200);

    } catch (error) {
      console.error(error);
      showStatus(`‚ùå Error: ${error.message}`, 'error');
    } finally {
      uploadBtn.disabled = false;
      cancelBtn.disabled = false;
    }
  }

  // Waveform play/pause
  function toggleWaveformPlay() {
    if (!waveSurfer) return;

    const btn = document.getElementById('waveformPlayBtn');
    const info = document.getElementById('waveformInfo');

    if (waveSurfer.isPlaying()) {
      waveSurfer.pause();
      btn.textContent = '‚ñ∂Ô∏è Play';
      info.textContent = 'Paused.';
    } else {
      waveSurfer.play();
      btn.textContent = '‚è∏ Pause';
      info.textContent = 'Playing...';
    }
  }

  // ===== Jobs Management =====
  function saveJobToSessionStorage(jobId, fileName) {
    let jobs = JSON.parse(sessionStorage.getItem('transcriptionJobs') || '[]');
    jobs.unshift({
      jobId,
      fileName,
      createdAt: new Date().toISOString(),
      status: 'waiting_upload'
    });
    jobs = jobs.slice(0, 50);
    sessionStorage.setItem('transcriptionJobs', JSON.stringify(jobs));
  }

  async function loadJobs() {
    const jobsList = document.getElementById('jobsList');
    const sessionJobs = JSON.parse(sessionStorage.getItem('transcriptionJobs') || '[]');

    if (!sessionJobs.length) {
      jobsList.innerHTML = `
        <div class="empty-state">
          <div class="empty-state-icon">üì≠</div>
          <h3>No transcriptions in this session</h3>
          <p>Upload an audio file to get started!</p>
        </div>
      `;
      return;
    }

    try {
      const response = await fetch(`${API_URL}/status`);
      const rawData = await response.json();
      const data = rawData.body ? JSON.parse(rawData.body) : rawData;

      const apiJobs = data.jobs || [];
      const apiMap = {};
      apiJobs.forEach(job => apiMap[job.jobId] = job);

      const jobsHtml = sessionJobs.map(sj => {
        const aj = apiMap[sj.jobId];
        const status = aj?.status || sj.status || 'waiting_upload';
        const createdAt = aj?.createdAt || sj.createdAt;
        return createJobCard(sj.jobId, sj.fileName, status, createdAt);
      }).join('');

      jobsList.innerHTML = jobsHtml;

      sessionJobs.forEach(sj => {
        const status = apiMap[sj.jobId]?.status;
        if (status === 'transcribing') startLivePolling(sj.jobId);
        if (status === 'completed' || status === 'failed') stopLivePolling(sj.jobId);
      });

      // restore open previews
      for (const jobId of openPreviews) {
        const panel = document.getElementById(`preview-${jobId}`);
        if (panel) {
          panel.style.display = 'block';
          if (panel.dataset.loaded !== 'true') {
            panel.dataset.loaded = 'true';
            loadPreview(jobId);
          }
        }
      }

    } catch (error) {
      console.error('Error loading jobs:', error);
    }
  }

  function createJobCard(jobId, fileName, status, createdAt) {
    const date = new Date(createdAt).toLocaleString();
    const statusClass = `status-${status}`;
    const statusText = status.replace('_', ' ');

    let actionsHtml = '';
    let livePanelHtml = '';

    if (status === 'completed') {
      actionsHtml = `
        <button class="btn btn-small download-btn" onclick="downloadFile('${jobId}', 'transcript')">üìÑ Transcript</button>
        <button class="btn btn-small download-btn" onclick="downloadFile('${jobId}', 'srt')">üìù SRT</button>
        <button class="btn btn-small download-btn" onclick="downloadFile('${jobId}', 'vtt')">üé¨ VTT</button>
        <button class="btn btn-small btn-secondary" onclick="togglePreview('${jobId}')">üëÄ Preview</button>
      `;
    } else if (status === 'transcribing') {
      actionsHtml = '<div class="spinner"></div>';
      livePanelHtml = `
        <div class="preview-panel">
          <strong>Live Preview (polling):</strong>
          <div id="livebox-${jobId}" class="live-box">
            Waiting for partial text...
          </div>
        </div>
      `;
    }

    return `
      <div class="job-card">
        <div class="job-header">
          <div>
            <strong>${fileName || 'Unknown File'}</strong><br>
            <span class="job-id">${jobId}</span><br>
            <small style="color:#6c757d;">${date}</small>
          </div>
          <span class="job-status ${statusClass}">${statusText}</span>
        </div>

        <div class="job-actions">${actionsHtml}</div>

        ${livePanelHtml}

        <div class="preview-panel" id="preview-${jobId}" style="display:none;">
          <div style="margin-bottom:10px;">
            <h4>Audio Playback</h4>
            <audio id="audio-${jobId}" controls
                   src="https://audio-transcribe-uploads-cs6620group9-1105.s3.amazonaws.com/uploads/${jobId}/audio.mp3">
            </audio>
          </div>

          <div id="preview-status-${jobId}" class="status-message info show">
            Loading transcript...
          </div>

          <div style="margin-top:10px;">
            <h4>Subtitle‚Äêstyle segments</h4>
            <div id="segments-${jobId}"></div>
          </div>

          <div style="margin-top:10px;">
            <h4>Full transcript</h4>
            <pre id="transcript-text-${jobId}"
                 style="white-space:pre-wrap;background:#fff;padding:10px;border-radius:8px;border:1px solid #eee;">
            </pre>
          </div>
        </div>
      </div>
    `;
  }

  function refreshJobs() {
    showStatus('Refreshing jobs...', 'info');
    loadJobs();
    setTimeout(hideStatus, 800);
  }

  // Live polling for partial transcript
  function startLivePolling(jobId) {
    if (livePollers[jobId]) return;

    livePollers[jobId] = setInterval(async () => {
      try {
        const r = await fetch(`${API_URL}/partial?jobId=${jobId}`);
        const raw = await r.json();
        const data = raw.body ? JSON.parse(raw.body) : raw;

        const box = document.getElementById(`livebox-${jobId}`);
        if (box) {
          box.textContent = data.partialText
            ? data.partialText
            : "Still processing... (batch Transcribe outputs at end)";
        }
      } catch (e) {
        console.error(e);
      }
    }, 3000);
  }

  function stopLivePolling(jobId) {
    if (!livePollers[jobId]) return;
    clearInterval(livePollers[jobId]);
    delete livePollers[jobId];
  }

  // ===== Preview logic =====
  async function togglePreview(jobId) {
    const panel = document.getElementById(`preview-${jobId}`);
    const isOpen = panel.style.display === 'block';

    if (isOpen) {
      panel.style.display = 'none';
      openPreviews.delete(jobId);
      return;
    }

    panel.style.display = 'block';
    openPreviews.add(jobId);

    if (panel.dataset.loaded === 'true') return;
    panel.dataset.loaded = 'true';

    await loadPreview(jobId);
  }

  async function loadPreview(jobId) {
    const statusDiv = document.getElementById(`preview-status-${jobId}`);
    const transcriptPre = document.getElementById(`transcript-text-${jobId}`);
    const segmentsDiv = document.getElementById(`segments-${jobId}`);

    statusDiv.textContent = 'Fetching transcript.json from S3...';
    statusDiv.className = 'status-message info show';

    const jsonUrl = `https://${RESULTS_BUCKET}.s3.amazonaws.com/transcripts/${jobId}/transcript.json`;

    const res = await fetch(jsonUrl);
    if (!res.ok) {
      statusDiv.textContent = `‚ùå Preview failed: ${res.statusText}`;
      statusDiv.className = 'status-message error show';
      return;
    }

    const data = await res.json();

    // 1) Build word timings from AWS Transcribe items
    const items = data.results?.items || [];
    const wordTimings = [];

    for (const it of items) {
      if (it.type !== 'pronunciation') continue;
      const start = parseFloat(it.start_time);
      const end   = parseFloat(it.end_time);
      const word  = it.alternatives?.[0]?.content || '';
      wordTimings.push({ start, end, word });
    }

    wordTimingsByJob[jobId] = wordTimings;
    currentWordIndexByJob[jobId] = 0;

    // 2) Render full transcript as clickable word spans
    if (wordTimings.length > 0) {
      const html = wordTimings.map((w, idx) =>
        `<span class="karaoke-word"
                data-idx="${idx}"
                data-start="${w.start}"
                data-end="${w.end}">
           ${w.word}
         </span>`
      ).join(' ');
      transcriptPre.innerHTML = html;
    } else {
      const fullText = (data.results && data.results.transcripts)
        ? data.results.transcripts.map(t => t.transcript).join("\n\n")
        : (data.text || JSON.stringify(data, null, 2));
      transcriptPre.textContent = fullText;
    }

    // 3) Build subtitle-style segments
    let segments = [];
    let cur = { start: null, end: null, text: [] };

    for (const w of wordTimings) {
      if (cur.start === null) cur.start = w.start;
      cur.end = w.end;
      cur.text.push(w.word);

      if (cur.end - cur.start > 4.5) {
        segments.push(cur);
        cur = { start: null, end: null, text: [] };
      }
    }
    if (cur.text.length) segments.push(cur);

    segmentsDiv.innerHTML = segments.length
      ? segments.map((seg, i) =>
          `<div class="segment-line"
                id="seg-${jobId}-${i}"
                data-start="${seg.start}">
             <strong>[${seg.start.toFixed(2)} ‚Üí ${seg.end.toFixed(2)}]</strong>
             ${seg.text.join(" ")}
           </div>`
        ).join('')
      : `<div style="color:#6c757d;">No word-level segments available.</div>`;

    statusDiv.textContent = '‚úÖ Subtitle preview loaded.';
    statusDiv.className = 'status-message success show';

    // 4) Wire audio ‚Üí highlight sync + click-to-seek
    const audio = document.getElementById(`audio-${jobId}`);

    if (audio && wordTimings.length > 0) {
      audio.addEventListener('timeupdate', () => {
        syncKaraoke(jobId, audio.currentTime);
      });

      transcriptPre.addEventListener('click', (e) => {
        const span = e.target.closest('.karaoke-word');
        if (!span) return;
        const t = parseFloat(span.dataset.start || '0');
        audio.currentTime = t;
      });

      segmentsDiv.addEventListener('click', (e) => {
        const line = e.target.closest('.segment-line');
        if (!line) return;
        const t = parseFloat(line.dataset.start || '0');
        audio.currentTime = t;
      });
    }
  }

  // Karaoke sync helper
  function syncKaraoke(jobId, currentTime) {
    const words = wordTimingsByJob[jobId];
    if (!words || words.length === 0) return;

    let idx = currentWordIndexByJob[jobId] ?? 0;

    while (idx < words.length - 1 && currentTime >= words[idx].end) {
      idx++;
    }
    while (idx > 0 && currentTime < words[idx].start) {
      idx--;
    }

    if (idx === currentWordIndexByJob[jobId]) return;
    currentWordIndexByJob[jobId] = idx;

    const container = document.getElementById(`transcript-text-${jobId}`);
    if (!container) return;

    const prev = container.querySelector('.karaoke-word.active');
    if (prev) prev.classList.remove('active');

    const next = container.querySelector(`.karaoke-word[data-idx="${idx}"]`);
    if (next) {
      next.classList.add('active');
      next.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
    }
  }

  // ===== Download files =====
  async function downloadFile(jobId, fileType) {
    try {
      let key, fileName;
      if (fileType === 'transcript') {
        key = `transcripts/${jobId}/transcript.json`;
        fileName = `transcript_${jobId}.json`;
      } else if (fileType === 'srt') {
        key = `transcripts/${jobId}/transcript.srt`;
        fileName = `subtitles_${jobId}.srt`;
      } else if (fileType === 'vtt') {
        key = `transcripts/${jobId}/transcript.vtt`;
        fileName = `subtitles_${jobId}.vtt`;
      } else {
        throw new Error('Unknown file type');
      }

      const url = `https://${RESULTS_BUCKET}.s3.amazonaws.com/${key}`;
      const r = await fetch(url);
      if (!r.ok) throw new Error('File not found. It may still be processing.');

      const blob = await r.blob();
      const dl = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = dl; a.download = fileName;
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      window.URL.revokeObjectURL(dl);

      showStatus('‚úÖ Download started!', 'success');
      setTimeout(hideStatus, 1500);

    } catch (e) {
      console.error(e);
      showStatus(`‚ùå Download failed: ${e.message}`, 'error');
    }
  }

  // ===== Utilities =====
  function formatFileSize(bytes) {
    if (bytes < 1024) return bytes + ' B';
    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
    return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
  }

  function showStatus(message, type) {
    const statusDiv = document.getElementById('uploadStatus');
    statusDiv.textContent = message;
    statusDiv.className = `status-message ${type} show`;
  }

  function hideStatus() {
    document.getElementById('uploadStatus').classList.remove('show');
  }

  document.addEventListener('DOMContentLoaded', () => {});
</script>
</body>
</html>
